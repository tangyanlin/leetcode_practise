## 动态规划三要素
### 重叠子结构
### 最优子结构
### 状态转移方程

## 写出状态转移方程：状态、选择、dp数组


```
    dp[0][0][...] = base case
    for 状态1 in 状态1的所有取值：
        for 状态2 in 状态2的所有取值:
            for ...
                dp[状态1][状态2][...] = 求最值(选择1，选择2，...)
```

## 典型题
### 斐波那契数列
### 凑零钱问题

# 背包问题
```
#二维
class Solution:
    def test(self, weights, bagWeight, values) -> bool:
        # dp[i][j]表示从下标为 0~i 的物品里任意取，放进容量为 j 的背包，价值总和的最大值
        # [物品个数行, 背包重量列]
        dp = [[0 for _ in range(bagWegiht+1)] for _ in range(len(weights))]   
        for j in (bagWeight, weights[0]-1, -1):  # 得放的下0物品
            # dp[0][j] = dp[0][j-wieghts[0]] + values[0]
            dp[0][j] = values[0]   
        for i in range(1, len(weights)):     # 遍历物品
                for j in range(1, bagWegiht+1):   # 遍历背包容量
                    # 如果当前包的容量放不下当前物品i, 那么就不放，dp[i][j]继续保持前面的累积最大价值
                    if j < weights[i]: dp[i][j] = dp[i-1][j]
                    else:
                        # 动态转移方程
                        dp[i][j] = max(dp[i-1][j], dp[i-1][j-weights[i]]+values[i])
        return dp[-1][-1]

```
```
#一维
class Solution:
    def test(self, weights, bagWeight, values) -> bool:
        # dp[i][j]表示从下标为 0~i 的物品里任意取，放进容量为 j 的背包，价值总和的最大值
        # [物品个数行, 背包重量列]
        dp = [0 for _ in range(bagWegiht+1)]  
        # dp[0] = 0
        for i in range(len(weights)):     # 遍历物品
            for j in range(bagWegiht, weights[i]-1, -1):   # 遍历背包容量
                 # 小于的时候dp[i][j]=dp[i-1][j] => dp[j]=dp[j] 所以无需判断
                 # 如果当前包的容量放不下当前物品i, 那么就不放，dp[i][j]继续保持前面的累积最大价值
                 if j >= weights[i]:
                     # 动态转移方程
                     dp[j] = max(dp[j], dp[j-weights[i]]+values[i])
        return dp[-1][-1]

```

